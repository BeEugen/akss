@article{smr-lamport,
author = {Lamport, Leslie},
title = {Time, clocks, and the ordering of events in a distributed system},
year = {1978},
issue_date = {July 1978},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {21},
number = {7},
issn = {0001-0782},
url = {https://doi.org/10.1145/359545.359563},
doi = {10.1145/359545.359563},
abstract = {The concept of one event happening before another in a distributed system is examined, and is shown to define a partial ordering of the events. A distributed algorithm is given for synchronizing a system of logical clocks which can be used to totally order the events. The use of the total ordering is illustrated with a method for solving synchronization problems. The algorithm is then specialized for synchronizing physical clocks, and a bound is derived on how far out of synchrony the clocks can become.},
journal = {Commun. ACM},
month = {jul},
pages = {558–565},
numpages = {8},
keywords = {multiprocess systems, distributed systems, computer networks, clock synchronization}
}

@article{smr-schneider,
author = {Schneider, Fred B.},
title = {Implementing fault-tolerant services using the state machine approach: a tutorial},
year = {1990},
issue_date = {Dec. 1990},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {22},
number = {4},
issn = {0360-0300},
url = {https://doi.org/10.1145/98163.98167},
doi = {10.1145/98163.98167},
abstract = {The state machine approach is a general method for implementing fault-tolerant services in distributed systems. This paper reviews the approach and describes protocols for two different failure models—Byzantine and fail stop. Systems reconfiguration techniques for removing faulty components and integrating repaired components are also discussed.},
journal = {ACM Comput. Surv.},
month = {dec},
pages = {299–319},
numpages = {21}
}

@InProceedings{smr-leaderless,
  author =	{Fran\c{c}a Rezende, Tuanir and Sutra, Pierre},
  title =	{{Leaderless State-Machine Replication: Specification, Properties, Limits}},
  booktitle =	{34th International Symposium on Distributed Computing (DISC 2020)},
  pages =	{24:1--24:17},
  series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN =	{978-3-95977-168-9},
  ISSN =	{1868-8969},
  year =	{2020},
  volume =	{179},
  editor =	{Attiya, Hagit},
  publisher =	{Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address =	{Dagstuhl, Germany},
  URL =		{https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.DISC.2020.24},
  URN =		{urn:nbn:de:0030-drops-131024},
  doi =		{10.4230/LIPIcs.DISC.2020.24},
  annote =	{Keywords: Fault Tolerance, State Machine Replication, Consensus}
}

@article{byzantine-generals-problem,
author = {Lamport, Leslie and Shostak, Robert and Pease, Marshall},
title = {The Byzantine Generals Problem},
year = {1982},
issue_date = {July 1982},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {4},
number = {3},
issn = {0164-0925},
url = {https://doi.org/10.1145/357172.357176},
doi = {10.1145/357172.357176},
journal = {ACM Trans. Program. Lang. Syst.},
month = {jul},
pages = {382–401},
numpages = {20}
}

@inproceedings{pbft,
author = {Castro, Miguel and Liskov, Barbara},
title = {Practical Byzantine fault tolerance},
year = {1999},
isbn = {1880446391},
publisher = {USENIX Association},
address = {USA},
booktitle = {Proceedings of the Third Symposium on Operating Systems Design and Implementation},
pages = {173–186},
numpages = {14},
location = {New Orleans, Louisiana, USA},
series = {OSDI '99}
}

@inproceedings{pbft-optimization,
author = {Castro, Miguel and Liskov, Barbara},
booktitle={2001 International Conference on Dependable Systems and Networks}, 
title={Byzantine fault tolerance can be fast}, 
year={2001},
volume={},
number={},
pages={513-518},
keywords={Fault tolerance;Fault tolerant systems;Libraries;File systems;Computer science;Protocols;Optimization;Laboratories;Production systems;Availability},
doi={10.1109/DSN.2001.941437}
}

@inproceedings{hotstuff,
author = {Yin, Maofan and Malkhi, Dahlia and Reiter, Michael K. and Gueta, Guy Golan and Abraham, Ittai},
title = {HotStuff: BFT Consensus with Linearity and Responsiveness},
year = {2019},
isbn = {9781450362177},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3293611.3331591},
doi = {10.1145/3293611.3331591},
abstract = {We present HotStuff, a leader-based Byzantine fault-tolerant replication protocol for the partially synchronous model. Once network communication becomes synchronous, HotStuff enables a correct leader to drive the protocol to consensus at the pace of actual (vs. maximum) network delay--a property called responsiveness---and with communication complexity that is linear in the number of replicas. To our knowledge, HotStuff is the first partially synchronous BFT replication protocol exhibiting these combined properties. Its simplicity enables it to be further pipelined and simplified into a practical, concise protocol for building large-scale replication services.},
booktitle = {Proceedings of the 2019 ACM Symposium on Principles of Distributed Computing},
pages = {347–356},
numpages = {10},
keywords = {scalability, responsiveness, consensus, byzantine fault tolerance, blockchain},
location = {Toronto ON, Canada},
series = {PODC '19}
}

@INPROCEEDINGS{pbft-liveness-problem,
  author={Berger, Christian and Reiser, Hans P. and Bessani, Alysson},
  booktitle={2021 40th International Symposium on Reliable Distributed Systems (SRDS)}, 
  title={Making Reads in BFT State Machine Replication Fast, Linearizable, and Live}, 
  year={2021},
  volume={},
  number={},
  pages={1-12},
  keywords={Wide area networks;Fault tolerance;Data centers;Protocols;Costs;System performance;Fault tolerant systems;Byzantine Fault Tolerance;State Machine Replication;Reads;Attack},
  doi={10.1109/SRDS53918.2021.00010}
}

@inproceedings{beegees,
author = {Giridharan, Neil and Suri-Payer, Florian and Ding, Matthew and Howard, Heidi and Abraham, Ittai and Crooks, Natacha},
title = {BeeGees: Stayin' Alive in Chained BFT},
year = {2023},
isbn = {9798400701214},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3583668.3594572},
doi = {10.1145/3583668.3594572},
abstract = {Modern chained Byzantine Fault Tolerant (BFT) systems leverage a combination of pipelining and leader rotation to obtain both efficiency and fairness. These protocols, however, require a sequence of three or four consecutive honest leaders to commit operations. Therefore, even simple leader failures such as crashes can weaken liveness, resulting in high commit latency or lack of commit all together. We show that, unfortunately, this vulnerability is inherent to all existing BFT protocols that rotate leaders with pipelined agreement. To resolve this liveness shortcoming we present BeeGees1, a novel chained BFT protocol that successfully commits blocks even with non-consecutive honest leaders. It does this while also maintaining quadratic word complexity with threshold signatures, linear word complexity with SNARKs, and responsiveness between consecutive honest leaders. BeeGees reduces the expected commit latency of HotStuff by a factor of three under failures, and the worst-case latency by a factor of seven.},
booktitle = {Proceedings of the 2023 ACM Symposium on Principles of Distributed Computing},
pages = {233–243},
numpages = {11},
keywords = {consensus, blockchain, BFT},
location = {Orlando, FL, USA},
series = {PODC '23}
}

@article{zyzzyva,
author = {Kotla, Ramakrishna and Alvisi, Lorenzo and Dahlin, Mike and Clement, Allen and Wong, Edmund},
title = {Zyzzyva: Speculative Byzantine fault tolerance},
year = {2010},
issue_date = {December 2009},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {27},
number = {4},
issn = {0734-2071},
url = {https://doi.org/10.1145/1658357.1658358},
doi = {10.1145/1658357.1658358},
abstract = {A longstanding vision in distributed systems is to build reliable systems from unreliable components. An enticing formulation of this vision is Byzantine Fault-Tolerant (BFT) state machine replication, in which a group of servers collectively act as a correct server even if some of the servers misbehave or malfunction in arbitrary (“Byzantine”) ways. Despite this promise, practitioners hesitate to deploy BFT systems, at least partly because of the perception that BFT must impose high overheads.In this article, we present Zyzzyva, a protocol that uses speculation to reduce the cost of BFT replication. In Zyzzyva, replicas reply to a client's request without first running an expensive three-phase commit protocol to agree on the order to process requests. Instead, they optimistically adopt the order proposed by a primary server, process the request, and reply immediately to the client. If the primary is faulty, replicas can become temporarily inconsistent with one another, but clients detect inconsistencies, help correct replicas converge on a single total ordering of requests, and only rely on responses that are consistent with this total order. This approach allows Zyzzyva to reduce replication overheads to near their theoretical minima and to achieve throughputs of tens of thousands of requests per second, making BFT replication practical for a broad range of demanding services.},
journal = {ACM Trans. Comput. Syst.},
month = {jan},
articleno = {7},
numpages = {39},
keywords = {speculative execution, replication, output commit, Byzantine fault tolerance}
}

@INPROCEEDINGS{bft-smart,
  author={Bessani, Alysson and Sousa, João and Alchieri, Eduardo E.P.},
  booktitle={2014 44th Annual IEEE/IFIP International Conference on Dependable Systems and Networks}, 
  title={State Machine Replication for the Masses with BFT-SMART}, 
  year={2014},
  volume={},
  number={},
  pages={355-362},
  keywords={Protocols;Message systems;Throughput;Computer crashes;Libraries;Robustness;Fault tolerance;state machine replication;byzantine fault tolerance},
  doi={10.1109/DSN.2014.43}
}

@inproceedings{aardvark,
author = {Clement, Allen and Kapritsos, Manos and Lee, Sangmin and Wang, Yang and Alvisi, Lorenzo and Dahlin, Mike and Riche, Taylor},
title = {Upright cluster services},
year = {2009},
isbn = {9781605587523},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1629575.1629602},
doi = {10.1145/1629575.1629602},
abstract = {The UpRight library seeks to make Byzantine fault tolerance (BFT) a simple and viable alternative to crash fault tolerance for a range of cluster services. We demonstrate UpRight by producing BFT versions of the Zookeeper lock service and the Hadoop Distributed File System (HDFS). Our design choices in UpRight favor simplifying adoption by existing applications; performance is a secondary concern. Despite these priorities, our BFT Zookeeper and BFT HDFS implementations have performance comparable with the originals while providing additional robustness.},
booktitle = {Proceedings of the ACM SIGOPS 22nd Symposium on Operating Systems Principles},
pages = {277–290},
numpages = {14},
keywords = {byzantine fault tolerance, cluster services, reliability},
location = {Big Sky, Montana, USA},
series = {SOSP '09}
}

@article{partial-sync-network,
author = {Dwork, Cynthia and Lynch, Nancy and Stockmeyer, Larry},
title = {Consensus in the presence of partial synchrony},
year = {1988},
issue_date = {April 1988},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {35},
number = {2},
issn = {0004-5411},
url = {https://doi.org/10.1145/42282.42283},
doi = {10.1145/42282.42283},
abstract = {The concept of partial synchrony in a distributed system is introduced. Partial synchrony lies between the cases of a synchronous system and an asynchronous system. In a synchronous system, there is a known fixed upper bound Δ on the time required for a message to be sent from one processor to another and a known fixed upper bound Φ on the relative speeds of different processors. In an asynchronous system no fixed upper bounds Δ and Φ exist. In one version of partial synchrony, fixed bounds Δ and Φ exist, but they are not known a priori. The problem is to design protocols that work correctly in the partially synchronous system regardless of the actual values of the bounds Δ and Φ. In another version of partial synchrony, the bounds are known, but are only guaranteed to hold starting at some unknown time T, and protocols must be designed to work correctly regardless of when time T occurs. Fault-tolerant consensus protocols are given for various cases of partial synchrony and various fault models. Lower bounds that show in most cases that our protocols are optimal with respect to the number of faults tolerated are also given. Our consensus protocols for partially synchronous processors use new protocols for fault-tolerant “distributed clocks” that allow partially synchronous processors to reach some approximately common notion of time.},
journal = {J. ACM},
month = {apr},
pages = {288–323},
numpages = {36}
}

@article{gst,
author = {Fischer, Michael J. and Lynch, Nancy A. and Paterson, Michael S.},
title = {Impossibility of distributed consensus with one faulty process},
year = {1985},
issue_date = {April 1985},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {32},
number = {2},
issn = {0004-5411},
url = {https://doi.org/10.1145/3149.214121},
doi = {10.1145/3149.214121},
abstract = {The consensus problem involves an asynchronous system of processes, some of which may be unreliable. The problem is for the reliable processes to agree on a binary value. In this paper, it is shown that every protocol for this problem has the possibility of nontermination, even with only one faulty process. By way of contrast, solutions are known for the synchronous case, the “Byzantine Generals” problem.},
journal = {J. ACM},
month = {apr},
pages = {374–382},
numpages = {9}
}

